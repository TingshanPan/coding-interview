# 1.2 Two Sum Pattern

## 1.2 Two Sum Pattern

## Summary

There will be two main method to solve the Two Sum Pattern problem: Two Points and HashMap.

### Two Pointers:

Use two pointers `left` and `right` start from beginning and the end. Each time check the sum `array[left] + array[right]` comparing to target.

* If `sum == target` : return solution
* If `sum > target` : `right--`
* If `sum < target` : `left++`

### HashMap:

Iterate over the whole array, for each number check whether `target - number` is in the HashMap.

* If `map.contains(target - number)` : return solution
* Else : add current number to the HashMap

The solution depends on how we clarify the problem:

* Sorted array: Prefer two pointers.
* Unsorted array: One pass scan and store in HashMap will be better.
* With duplicates: May need extra HashSet to deduplicate.

## Problems

### 2 Sum

The source code of Two Sum Pattern problems: [two sum solution](https://github.com/zdong1995/coding-interview/tree/master/src/algorithm/array/twosum)

#### 2 Sum - Unsorted

HashMap to store the visited element, for each iteration, check whether the complement in the map.

```java
// HashMap: Time O(n), Space O(n)
public int[] twoSum(int[] array, int target) {
  if (array == null || array.length == 0) {
    return new int[] {-1, -1};
  }
  Map<Integer, Integer> seen = new HashMap<>(); // <value, index>
  for (int i = 0; i < array.length; i++) {
    if (seen.containsKey(target - array[i])) {
      return new int[] {i, seen.get(target - array[i])};
    } else {
      seen.put(array[i], i);
    }
  }
  return new int[] {-1, -1};
}
```

#### 2 Sum - Sorted

Two pointers from begin and end, decrement right when `sum > target`, increment left when `sum < target`.

```java
// Two Pointers: Time O(n), Space O(1)
public int[] twoSumSorted(int[] nums, int target) {
  if (nums == null || nums.length == 0) {
    return new int[] {-1, -1};
  }
  int left = 0;
  int right = nums.length - 1;
  while (left < right) {
    int sum = nums[left] + nums[right];
    if (sum == target) {
      return new int[] {left, right};
    } else if (sum > target) {
      right--;
    } else {
      left++;
    }
  }
  return new int[] {-1, -1};
}
```

#### 2 Sum - All Pairs Indices

HashMap to store number and list of indices, for each iteration, check the complement and enumerate all possible indices pairs of current number pair.

```java
// HashMap: Time O(n), Space O(n)
public List<List<Integer>> twoSumAllPairs(int[] array, int target) {
  List<List<Integer>> res = new ArrayList<>();
  Map<Integer, List<Integer>> visited = new HashMap<>();
  // key = number, value = list of indices

  for (int i = 0; i < array.length; i++) {
    int diff = target - array[i];
    List<Integer> indices = visited.get(diff);
    if (indices != null) {
      // enumerate all possible indices pairs of current (array[i], diff) pair
      for (int idx : indices) {
        res.add(Arrays.asList(i, idx));
      }
    }
    visited.putIfAbsent(array[i], new ArrayList<>());
    visited.get(array[i]).add(i);
  }
  return res;
}
```

#### 2 Sum - All Unique Pairs

* Solution 1: Sort + Two Pointers, skip duplicates after finding pairs
* Solution 2: HashMap to record `<number, index>`, and Set to deduplicate pair

{% tabs %}
{% tab title="Two Pointers" %}
```java
// Solution 1: Sort + Two pointers
// Time O(nlogn + n) = O(nlogn), Space O(n)
public List<List<Integer>> twoSumAllUniquePairs(int[] array, int target) {
  List<List<Integer>> res = new ArrayList<>();
  if (array == null || array.length == 0) {
    return res;
  }
  Arrays.sort(array);
  int left = 0;
  int right = array.length - 1;
  while (left < right) {
    int sum = array[left] + array[right];
    if (sum == target) {
      res.add(Arrays.asList(array[left++], array[right--]));
      // deduplicate
      while (left < right && array[left] == array[left - 1]) {
        left++;
      }
      while (left < right && array[right] == array[right + 1]) {
        right--;
      }
    } else if (sum > target){
      right--;
      while (left < right && array[right] == array[right + 1]) { // optional
        right--;
      }
    } else {
      left++;
      while (left < right && array[left] == array[left - 1]) { // optional
        left++;
      }
    }
  }
  return res;
}
```
{% endtab %}

{% tab title="HashMap" %}
```java
// Solution 2: HashMap
// Time O(n), Space O(n)
public List<List<Integer>> twoSumAllUniquePairsHashMap(int[] array, int target) {
  List<List<Integer>> res = new ArrayList<>();
  if (array == null || array.length == 0) {
    return res;
  }

  Map<Integer, Integer> visited = new HashMap<>(); // number, first appeared index
  Set<Integer> used = new HashSet<>(); // indices used in solution pairs

  for (int i = 0; i < array.length; i++) {
    int diff = target - array[i];
    if (visited.containsKey(diff)) {
      // need to check whether this pair is already used before
      if (!used.contains(array[i]) && !used.contains(diff)) {
        res.add(Arrays.asList(array[i], diff));
        used.add(array[i]);
        used.add(diff);
      }
    } else {
      visited.put(array[i], i);
    }
  }
  return res;
}
```
{% endtab %}
{% endtabs %}

#### 2 Sum - Greater

Sort + Two Pointers, when sum is greater than target, than for current right, the pair sum with left in range `[left, right)` will all be greater than target.

```java
// Sort + TwoPointers
// Time O(nlogn + n) = O(n), Space O(n)
public int twoSumGreater(int[] array, int target) {
  if (array == null || array.length == 0) {
    return 0;
  }
  Arrays.sort(array);
  int left = 0;
  int right = array.length - 1;
  int count = 0;

  while (left < right) {
    int sum = array[left] + array[right];
    if (sum > target) {
      // all the pair that left in the range [left, right)
      // will be greater than target
      count += right - left;
      right--;
    } else {
      left++;
    }
  }
  return count;
}
```

#### 2 Sum - Smaller

Sort + Two Pointers, when sum is smaller than target, than for current left, the pair sum with right in range `(left, right]` will all be smaller than target.

```java
// Sort + TwoPointers
// Time O(nlogn + n) = O(n), Space O(n)
public int twoSumSmaller(int[] array, int target) {
  if (array == null || array.length == 0) {
    return 0;
  }
  Arrays.sort(array);
  int left = 0;
  int right = array.length - 1;
  int count = 0;

  while (left < right) {
    int sum = array[left] + array[right];
    if (sum < target) {
      // all the pair that right in the range (left, right]
      // will be smaller than target
      count += right - left;
      left++;
    } else {
      right--;
    }
  }
  return count;
}
```

Sort + Two Pointers, maintain one global min difference, update result if the difference between sum and target is smaller.

#### 2 Sum - Data Structure Design

Optimize `add()`:

* Solution 1: HashMap for counter, add O\(1\) and find O\(n\)
* Solution 2: ArrayList + Sort + Two Pointers to find, add O\(1\) and find O\(nlogn\)

Optimize `find()`:

* Solution 1: HashMap for counter + Set for all sums, add O\(n\) and find O\(1\) 
* Solution 2: ArrayList + Insertion Sort + Two Pointers to find, add O\(n\) and find O\(n\)

```java
public class TwoSumDesign {
  // HashMap -> Optimize add
  // Time: add O(1), find O(n)
  // Space: O(n)
  Map<Integer, Integer> counter;

  public TwoSumDesign() {
    this.counter = new HashMap<>();
  }

  public void add(int number) {
    counter.put(number, counter.getOrDefault(number, 0) + 1);
  }

  public boolean find(int value) {
    for (int num : counter.keySet()) {
      int diff = value - num;
      int countNeeded = num == diff ? 2 : 1;
      if (counter.getOrDefault(diff, 0) >= countNeeded ) {
        return true;
      }
    }
    return false;
  }
}
```

#### 2 Sum - Difference

* Solution 1: Two Pointers similar to sliding window, guarantee `left < right` and not out of bound
* Solution 2: HashMap and check whether `array[i] + target` or `array[i] - target` in the map

```java
// Two Pointers: Time O(n), Space O(1)
public static int[] twoSumDifference(int[] array, int target) {
  if (array == null || array.length == 0) {
    return new int[0];
  }
  target = Math.abs(target); // min - max = -1 * (max - min)
  int left = 0;
  int right = 1;

  while (left < right && right < array.length) {
    int diff = array[right] - array[left];
    if (diff == target) {
      return new int[] {array[left], array[right]};
    } else if (diff < target) { // right is not big enough
      right++;
    } else { // left is a little small
      left++;
      if (left == right) { // left and right can't be the same
        right++;
      }
    }
  }
  return new int[] {-1, -1};
}
```

### 3 Sum

#### 3 Sum

* Solution 1: Sort + Two Pointers, for each fixed number `array[i]`, find two sum that sums to `target - array[i]`
* Solution 2: Sort + HashMap, count the occurrence of each number, for for loop to find a triplet that `array[left] <= array[right] <= (target - array[left] - array[right])` in order to deduplicate

{% tabs %}
{% tab title="Two Pointers" %}
```java
// Method 1: Sort + For loop 2 Sum
// Time O(n^2 + nlogn) = O(n^2), Space O(n) for sort
public static List<List<Integer>> threeSum(int[] array, int target) {
  List<List<Integer>> res = new ArrayList<>();
  if (array == null || array.length == 0) {
    return res;
  }
  Arrays.sort(array);

  for (int i = 0; i < array.length - 2; i++) {
    // run two sum to find pair equal to - target in range (i, n-1]
    if (i > 0 && array[i] == array[i - 1]) { // skip duplicate start index
      continue;
    }
    int left = i + 1;
    int right = array.length - 1;
    while (left < right) {
      int sum = array[left] + array[right];
      if (sum == target - array[i]) {
        res.add(Arrays.asList(array[i], array[left++], array[right--]));
        // skip duplicates
        while (left < right && array[left] == array[left - 1]) {
          left++;
        }
        while (left < right && array[right] == array[right + 1]) {
          right--;
        }
      } else if (sum < target - array[i]) {
        left++;
      } else {
        right--;
      }
    }
  }
  return res;
}
```
{% endtab %}

{% tab title="HashMap" %}
```java
// Method 2: Sort + HashMap to store first two sum
// Time: O(n^2 + nlogn) = O(n^2), Space = O(n) for sort + map
public static List<List<Integer>> threeSum2(int[] array, int target) {
  List<List<Integer>> res = new ArrayList<>();
  if (array == null || array.length == 0) {
    return res;
  }
  Arrays.sort(array);

  Map<Integer, Integer> counter = new HashMap<>();
  for (int num : array) {
    counter.put(num, counter.getOrDefault(num, 0) + 1);
  }

  int left = 0;
  while (left < array.length - 1) {
    for (int right = left + 1; right < array.length; right++) {
      int diff = target - array[left] - array[right];
      int diffNeeded = 1;
      if (array[left] == diff) {
        diffNeeded++;
      }
      if (array[right] == diff) {
        diffNeeded++;
      }
      if (counter.getOrDefault(diff, 0) >= diffNeeded && diff >= array[right]) {
        // strictly maintain array[left] <= array[right] <= diff to deduplicate
        res.add(Arrays.asList(array[left], array[right], diff));
      }
      // deduplicate
      while (right < array.length - 1 && array[right] == array[right + 1]) {
        right++;
      }
    }
    // deduplicate
    while (left < array.length - 1 && array[left] == array[left + 1]) {
      left++;
    }
    left++;
  }
  return res;
}
```
{% endtab %}
{% endtabs %}

#### 3 Sum - Greater

#### 3 Sum - Closest

### 4 Sum

